= GIT-FORMAT-PATCH(1)

== Name

* git-format-patch - Prepare patches for e-mail submission

== Description

* Prepare each non-merge commit with its "patch" in one "message" per commit,
  formatted to resemble a UNIX mailbox.
* The output of this command is convenient for e-mail submission or for use with
  [.underline]#git# [.underline]#am#.

'''

* A "message" generated by the command consists of three parts:
** A brief metadata header that begins with *From <commit>* with a fixed *Mon
   Sep 17 00:00:00 2001* datestamp to help programs like "file(1)" to recognize
   that the file is an output from this command, fields that record the author
   identity, the author date, and the title of the change (taken from the first
   paragraph of the commit log message).
** The second and subsequent paragraphs of the commit log message.
** The "patch", which is the "diff -p --stat" output (see *git-diff*(1)) between
   the commit and its parent.

* The log message and the patch are separated by a line with a three-dash line.

'''

* There are two ways to specify which commits to operate on.
. A single commit, <since>, specifies that the commits leading to the tip of the
  current branch that are not in the history that leads to the <since> to be
  output.
. Generic <revision-range> expression (see "SPECIFYING REVISIONS" section in
  *gitrevisions*(7)) means the commits in the specified range.

* The first rule takes precedence in the case of a single <commit>.
* To apply the second rule, i.e., format everything since the beginning of
  history up until <commit>, use the *--root* option: *git format-patch --root
  <commit>*.
* If you want to format only <commit> itself, you can do this with *git
  format-patch -1 <commit>*.

'''

* By default, each output file is numbered sequentially from 1, and uses the
  first line of the commit message (massaged for pathname safety) as the
  filename.
* With the *--numbered-files* option, the output file names will only be
  numbers, without the first line of the commit appended.
* The names of the output files are printed to standard output, unless the
  *--stdout* option is specified.

'''

* If *-o* is specified, output files are created in <dir>.
* Otherwise they are created in the current working directory.
* The default path can be set with the *format.outputDirectory* configuration
  option.
* The *-o* option takes precedence over *format.outputDirectory*.
* To store patches in the current working directory even when
  *format.outputDirectory* points elsewhere, use *-o .*.
* All directory components will be created.

'''

* By default, the subject of a single patch is "[PATCH] " followed by the
  concatenation of lines from the commit message up to the first blank line (see
  the DISCUSSION section of *git-commit*(1)).

'''

* When multiple patches are output, the subject prefix will instead be "[PATCH n/m] ".
* To force 1/1 to be added for a single patch, use *-n*.
* To omit patch numbers from the subject, use *-N*.

'''

* If given *--thread*, *git-format-patch* will generate *In-Reply-To* and
  *References* headers to make the second and subsequent patch mails appear as
  replies to the first mail; this also generates a *Message-ID* header to
  reference.

== Mua-specific hints

* Here are some hints on how to successfully submit patches inline using various
  mailers.

=== GMail

* GMail does not have any way to turn off line wrapping in the web interface, so
  it will mangle any emails that you send.
* You can however use "git send-email" and send your patches through the GMail
  SMTP server, or use any IMAP email client to connect to the google IMAP server
  and forward the emails through that.

'''

* For hints on using [.underline]#git# [.underline]#send-email# to send your
  patches through the GMail SMTP server, see the EXAMPLE section of
  *git-send-email*(1).

'''

* For hints on submission using the IMAP interface, see the EXAMPLE section of
  *git-imap-send*(1).

== Base tree information

* The base tree information block is used for maintainers or third party testers
  to know the exact state the patch series applies to.
* It consists of the [.underline]#base commit#, which is a well-known commit
  that is part of the stable part of the project history everybody else works
  off of, and zero or more [.underline]#prerequisite patches#, which are
  well-known patches in flight that is not yet part of the [.underline]#base
  commit# that need to be applied on top of [.underline]#base commit# in
  topological order before the patches can be applied.

'''

* The [.underline]#base commit# is shown as "base-commit: " followed by the
  40-hex of the commit object name.
* A [.underline]#prerequisite patch# is shown as "prerequisite-patch-id: "
  followed by the 40-hex [.underline]#patch id#, which can be obtained by
  passing the patch through the *git patch-id --stable* command.

'''

* Imagine that on top of the public commit P, you applied well-known patches X,
  Y and Z from somebody else, and then built your three-patch series A, B, C,
  the history would be like:
+
....
    ---P---X---Y---Z---A---B---C
....

* With *git format-patch --base=P -3 C* (or variants thereof, e.g. with
  *--cover-letter* or using *Z..C* instead of *-3 C *to specify the range), the
  base tree information block is shown at the end of the first message the command
  outputs (either the first patch, or the cover letter), like this:
+
....
    base-commit: P
    prerequisite-patch-id: X
    prerequisite-patch-id: Y
    prerequisite-patch-id: Z
....

* For non-linear topology, such as
+
....
    ---P---X---A---M---C
        \         /
         Y---Z---B
....

* You can also use *git format-patch --base=P -3 C* to generate patches for A, B
  and C, and the identifiers for P, X, Y, Z are appended at the end of the first
  message.

'''

* If set *--base=auto* in cmdline, it will automatically compute the base commit
  as the merge base of tip commit of the remote-tracking branch and
  revision-range specified in cmdline.
* For a local branch, you need to make it to track a remote branch by *git
  branch --set-upstream-to* before using this option.

== Examples

* Extract commits between revisions R1 and R2, and apply them on top of the
  current branch using [.underline]#git am# to cherry-pick them:
+
[source,sh]
$ git format-patch -k --stdout R1..R2 | git am -3 -k

* Extract all commits which are in the current branch but not in the origin branch:
+
[source,sh]
$ git format-patch origin

** For each commit a separate file is created in the current directory.

* Extract all commits that lead to [.underline]#origin# since the inception of
  the project:
+
[source,sh]
$ git format-patch --root origin

* The same as the previous one:
+
[source,sh]
$ git format-patch -M -B origin

** Additionally, it detects and handles renames and complete rewrites
   intelligently to produce a renaming patch.
** A renaming patch reduces the amount of text output, and generally makes it
   easier to review.
** Note that non-Git "patch" programs won't understand renaming patches, so use
   it only when you know the recipient uses Git to apply your patch.

* Extract three topmost commits from the current branch and format them as
  e-mailable patches:
+
[source,sh]
$ git format-patch -3

== Caveats

* Note that *format-patch* will omit merge commits from the output, even if they
  are part of the requested range.
* A simple "patch" does not include enough information for the receiving end to
  reproduce the same merge commit.

== See also

* *git-am*(1), *git-send-email*(1)

== Git

* Part of the *git*(1) suite

|===
|Git 2.47.1	|11/25/2024
|===
