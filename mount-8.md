# MOUNT(8)

## NAME

- mount - mount a filesystem

## SYNOPSIS

<pre><b>mount</b> [<b>-l</b>] [<b>-t</b> <u>fstype</u>]</pre>

<pre><b>mount</b> [<b>-fnsrsvw</b>] [<b>-t</b> <u>fstype</u>] [<b>-o</b> <u>options</u>] <u>device</u> <u>mountpoint</u></pre>

## DESCRIPTION

- All files accessible in a Unix system are arranged in one big tree, the file hierarchy, rooted at <u>/</u>.

- These files can be spread out over several devices.

- The **mount** command serves to attach the filesystem found on some device to the big file tree.

- Conversely, the **umount**(8) command will detach it again.

- The filesystem is used to control how data is stored on the device or provided in a virtual way by network or other services.

<br>

- The standard form of the mount command is:

    <pre><b>mount</b> <b>-t</b> <u>type</u> <u>device</u> <u>dir</u></pre>

- This tells the kernel to attach the filesystem found on <u>device</u> (which is of type <u>type</u>) at the directory <u>dir</u>.

- The option **-t** <u>type</u> is optional.

- The **mount** command is usually able to detect a filesystem.

- The root permissions are necessary to mount a filesystem by default.

- See section "Non-superuser mounts" below for more details.

- The previous contents (if any) and owner and mode of <u>dir</u> become invisible, and as long as this filesystem remains mounted, the pathname <u>dir</u> refers to the root of the filesystem on <u>device</u>.

<br>

- If only the directory or the device is given, for example:

    <pre><b>mount</b> <u>/dir</u></pre>

    - then **mount** looks for a mountpoint (and if not found then for a device) in the <u>/etc/fstab</u> file.

- It’s possible to use the **--target** or **--source** options to avoid ambiguous interpretation of the given argument.

- For example:

    <pre><b>mount</b> <b>--target</b> <u>/mountpoint</u>

- The same filesystem may be mounted more than once, and in some cases (e.g., network filesystems) the same filesystem may be mounted on the same mountpoint multiple times.

- The **mount** command does not implement any policy to control this behavior.

- All behavior is controlled by the kernel and it is usually specific to the filesystem driver.

- The exception is **--all**, in this case already mounted filesystems are ignored (see **--all** below for more details).

### Listing the mounts

- The listing mode is maintained for backward compatibility only.

<br>

- For more robust and customizable output use **findmnt**(8), **especially in your scripts**.

- Note that control characters in the mountpoint name are replaced with '?'.

<br>

- The following command lists all mounted filesystems (of type type):

    <pre><b>mount</b> [<b>-l</b>] [<b>-t</b> <u>type</u>]</pre>

- The option **-l** adds labels to this listing.

- See below.

### Indicating the device and filesystem

- Most devices are indicated by a filename (of a block special device), like <u>/dev/sda1</u>, but there are other possibilities.

- For example, in the case of an NFS mount, device may look like <u>knuth.cwi.nl:/dir</u>.

<br>

- The device names of disk partitions are unstable; hardware reconfiguration, and adding or removing a device can cause changes in names.

- This is the reason why it’s strongly recommended to use filesystem or partition identifiers like UUID or LABEL.

- Currently supported identifiers (tags):

    - LABEL=<u>label</u>

        - Human readable filesystem identifier.

        - See also **-L**.

    - UUID=<u>uuid</u>

        - Filesystem universally unique identifier.

        - The format of the UUID is usually a series of hex digits separated by hyphens.

        - See also **-U**.

        <br>

        - Note that **mount** uses UUIDs as strings.

        - The UUIDs from the command line or from **fstab**(5) are not converted to internal binary representation.

        - The string representation of the UUID should be based on lower case characters.

    - PARTLABEL=<u>label</u>

        - Human readable partition identifier.

        - This identifier is independent on filesystem and does not change by **mkfs** or **mkswap** operations.

        - It’s supported for example for GUID Partition Tables (GPT).

    - PARTUUID=<u>uuid</u>

        - Partition universally unique identifier.

        - This identifier is independent on filesystem and does not change by **mkfs** or **mkswap** operations.

        - It’s supported for example for GUID Partition Tables (GPT).

    - ID=<u>id</u>

        - Hardware block device ID as generated by udevd.

        - This identifier is usually based on WWN (unique storage identifier) and assigned by the hardware manufacturer.

        - See **ls /dev/disk/by-id** for more details, this directory and running udevd is required.

        - This identifier is not recommended for generic use as the identifier is not strictly defined and it depends on udev, udev rules and hardware.

- The command **lsblk --fs** provides an overview of filesystems, LABELs and UUIDs on available block devices.

- The command **blkid -p <device>** provides details about a filesystem on the specified device.

<br>

- Don’t forget that there is no guarantee that UUIDs and labels are really unique, especially if you move, share or copy the device.

- Use **lsblk -o +UUID,PARTUUID** to verify that the UUIDs are really unique in your system.

<br>

- The recommended setup is to use tags (e.g. **UUID**=<u>uuid</u>) rather than <u>/dev/disk/by-{label,uuid,id,partuuid,partlabel}</u> udev symlinks in the <u>/etc/fstab</u> file.

- Tags are more readable, robust and portable.

- The **mount**(8) command internally uses udev symlinks, so the use of symlinks in <u>/etc/fstab</u> has no advantage over tags.

- For more details see **libblkid**(3).

<br>

- The <u>proc</u> filesystem is not associated with a special device, and when mounting it, an arbitrary keyword - for example, <u>proc</u> - can be used instead of a device specification.

    - The customary choice <u>none</u> is less fortunate: the error message 'none already mounted' from **mount** can be confusing.

### The files /etc/fstab, /etc/mtab and /proc/mounts

- The file <u>/etc/fstab</u> (see **fstab**(5)), may contain lines describing what devices are usually mounted where, using which options.

- The default location of the **fstab**(5) file can be overridden with the **--fstab** <u>path</u> command-line option (see below for more details).

<br>

- The command

    <pre>**mount** **-a** [**-t** <u>type</u>] [**-O** <u>optlist</u>]</pre>

    - (usually given in a bootscript) causes all filesystems mentioned in <u>fstab</u> (of the proper type and/or having or not having the proper options) to be mounted as indicated, except for those whose line contains the **noauto** keyword.

- When mounting a filesystem mentioned in <u>fstab</u> or <u>mtab</u>, it suffices to specify on the command line only the device, or only the mount point.

<br>

- The programs **mount** and **umount**(8) traditionally maintained a list of currently mounted filesystems in the file <u>/etc/mtab</u>.

- The support for regular classic <u>/etc/mtab</u> is completely disabled at compile time by default, because on current Linux systems it is better to make <u>/etc/mtab</u> a symlink to <u>/proc/mounts</u> instead.

- The regular <u>mtab</u> file maintained in userspace cannot reliably work with namespaces, containers and other advanced Linux features.

- If the regular <u>mtab</u> support is enabled, then it’s possible to use the file as well as the symlink.

<br>

- If no arguments are given to mount, the list of mounted filesystems is printed.

<br>

- If you want to override mount options from <u>/etc/fstab</u>, you have to use the **-o** option:

    <pre><b>mount</b> <u>device</u>|<u>dir</u> **-o** <u>options</u><pre>

    - and then the mount options from the command line will be appended to the list of options from <u>/etc/fstab</u>.

    - This default behaviour can be changed using the **--options-mode** command-line option.

    - The usual behavior is that the last option wins if there are conflicting ones.

<br>

- The **mount** program does not read the <u>/etc/fstab</u> file if both device (or LABEL, UUID, ID, PARTUUID or PARTLABEL) and <u>dir</u> are specified.

- For example, to mount device **foo** at **/dir**:

    <pre><b>mount</b> <b>/dev/foo</b> <b>/dir</b>

- This default behaviour can be changed by using the **--options-source-force** command-line option to always read configuration from <u>fstab</u>.

- For non-root users mount always reads the <u>fstab</u> configuration.

### Non-superuser mounts

- Normally, only the superuser can mount filesystems.

- However, when <u>fstab</u> contains the user option on a line, anybody can mount the corresponding filesystem.

- Thus, given a line

    <pre><b>/dev/cdrom</b> <b>/cd</b> <b>iso9660</b>
    <b>ro,user,noauto,unhide</b></pre>

    - any user can mount the iso9660 filesystem found on an inserted CDROM using the command:

    <pre><b>mount</b> <b>/cd</b>

- Note that **mount** is very strict about non-root users and all paths specified on command line are verified before <u>fstab</u> is parsed or a helper program is executed.

- It’s strongly recommended to use a valid mountpoint to specify filesystem, otherwise mount may fail.

- For example it’s a bad idea to use NFS or CIFS source on command line.

<br>

- Since util-linux 2.35, mount does not exit when user permissions are inadequate according to libmount's internal security rules.

- Instead, it drops suid permissions and continues as regular non-root user.

- This behavior supports use-cases where root permissions are not necessary (e.g., fuse filesystems, user namespaces, etc).

<br>

- For more details, see **fstab**(5).

- Only the user that mounted a filesystem can unmount it again.

- If any user should be able to unmount it, then use **users** instead of **user** in the <u>fstab</u> line.

- The **owner** option is similar to the **user** option, with the restriction that the user must be the owner of the special file.

- This may be useful e.g. for <u>/dev/fd</u> if a login script makes the console user owner of this device.

- The **group** option is similar, with the restriction that the user must be a member of the group of the special file.

<br>

- The **user** mount option is accepted if no username is specified.

- If used in the format **user=someone**, the option is silently ignored and visible only for external mount helpers (/sbin/mount.<type>) for compatibility with some network filesystems.

### Bind mount operation

- Remount part of the file hierarchy somewhere else.

- The call is:

    <pre><b>mount</b> <b>--bind</b> <u>olddir</u> <u>newdir</u></pre>

    - or by using this <u>fstab</u> entry:

    <pre>/<u>olddir</u> /<u>newdir</u> <b>none</b> <b>bind</b></pre>

- After this call the same contents are accessible in two places.

<br>

- It is important to understand that "bind" does not create any second-class or special node in the kernel VFS.

- The "bind" is just another operation to attach a filesystem.

- There is nowhere stored information that the filesystem has been attached by a "bind" operation.

- The <u>olddir</u> and <u>newdir</u> are independent and the <u>olddir</u> may be unmounted.

<br>

- One can also remount a single file (on a single file).

- It’s also possible to use a bind mount to create a mountpoint from a regular directory, for example:

    <pre><b>mount</b> <b>--bind</b> <b>foo</b> <b>foo</b></pre>

- The bind mount call attaches only (part of) a single filesystem, not possible submounts.

- The entire file hierarchy including submounts can be attached a second place by using:

    <pre><b>mount</b> <b>--rbind</b> <u>olddir</u> <u>newdir</u></pre>

- Note that the filesystem mount options maintained by the kernel will remain the same as those on the original mount point.

- The userspace mount options (e.g., _netdev) will not be copied by **mount** and it’s necessary to explicitly specify the options on the mount command line.

<br>

- Since util-linux 2.27 **mount** permits changing the mount options by passing the relevant options along with **--bind**.

- For example:

    <pre><b>mount</b> <b>-o</b> <b>bind,ro</b> <b>foo</b> <b>foo</b></pre>

- This feature is not supported by the Linux kernel; it is implemented in userspace by an additional **mount**(2) remounting system call.

- This solution is not atomic.

<br>

- The alternative (classic) way to create a read-only bind mount is to use the remount operation, for example:

    <pre><b>mount</b> <b>--bind</b> <u>olddir</u> <u>newdir</u></pre>

    <pre><b>mount</b> <b>-o</b> <b>remount,bind,ro</b> <u>olddir</u> <u>newdir</u></pre>

- Note that a read-only bind will create a read-only mountpoint (VFS entry), but the original filesystem superblock will still be writable, meaning that the olddir will be writable, but the newdir will be read-only.

<br>

- It’s also possible to change nosuid, nodev, noexec, noatime, nodiratime, relatime and nosymfollow VFS entry flags via a "remount,bind" operation.

- The other flags (for example filesystem-specific flags) are silently ignored.

- The classic **mount**(2) system call does not allow to change mount options recursively (for example with **-o rbind,ro**).

- The recursive semantic is possible with a new **mount_setattr**(2) kernel system call and it’s supported since libmount from util-linux v2.39 by a new experimental "recursive" option argument (e.g. -o **rbind,ro=recursive**).

- For more details see the **FILESYSTEM-INDEPENDENT MOUNT OPTIONS** section.

<br>

- Since util-linux 2.31, **mount** ignores the **bind** flag from <u>/etc/fstab</u> on a **remount** operation (if **-o remount** is specified on command line).

- This is necessary to fully control mount options on remount by command line.

- In previous versions the bind flag has been always applied and it was impossible to re-define mount options without interaction with the bind semantic.

- This **mount** behavior does not affect situations when "remount,bind" is specified in the <u>/etc/fstab</u> file.

### The move operation

- Move a mounted tree to another place (atomically).

- The call is:

    <pre><b>mount</b> <b>--move</b> <u>olddir</u> <u>newdir</u></pre>

- This will cause the contents which previously appeared under <u>olddir</u> to now be accessible under <u>newdir</u>.

- The physical location of the files is not changed.

- Note that <u>olddir</u> has to be a mountpoint.

<br>

- Note also that moving a mount residing under a shared mount is invalid and unsupported.

- Use **findmnt -o TARGET,PROPAGATION** to see the current propagation flags.

### Shared subtree operations

- Since Linux 2.6.15 it is possible to mark a mount and its submounts as shared, private, slave or unbindable.

- A shared mount provides the ability to create mirrors of that mount such that mounts and unmounts within any of the mirrors propagate to the other mirror.

- A slave mount receives propagation from its master, but not vice versa.

- A private mount carries no propagation abilities.

- An unbindable mount is a private mount which cannot be cloned through a bind operation.

- The detailed semantics are documented in <u>Documentation/filesystems/sharedsubtree.txt</u> file in the kernel source tree; see also **mount_namespaces**(7).

- Supported operations are:

      mount --make-shared mountpoint
      mount --make-slave mountpoint
      mount --make-private mountpoint
      mount --make-unbindable mountpoint

- The following commands allow one to recursively change the type of all the mounts under a given mountpoint.

      mount --make-rshared mountpoint
      mount --make-rslave mountpoint
      mount --make-rprivate mountpoint
      mount --make-runbindable mountpoint

- **mount does not read** **fstab**(5) when a **--make-*** operation is requested.

- All necessary information has to be specified on the command line.

<br>

- Note that the Linux kernel does not allow changing multiple propagation flags with a single **mount**(2) system call, and the flags cannot be mixed with other mount options and operations.

<br>

- Since util-linux 2.23 the **mount** command can be used to do more propagation (topology) changes by one **mount**(8) call and do it also together with other mount operations.

- The propagation flags are applied by additional **mount**(2) system calls when the preceding mount operations were successful.

- Note that this use case is not atomic.

- It is possible to specify the propagation flags in **fstab**(5) as mount options (**private, slave, shared, unbindable, rprivate, rslave, rshared, runbindable**).

<br>

- For example:

    ```
    mount --make-private --make-unbindable /dev/ sda1 /foo
    ```

    - is the same as:

    ```
    mount /dev/sda1 /foo
    mount --make-private /foo
    mount --make-unbindable /foo
    ```

## COMMAND-LINE OPTIONS

- The full set of mount options used by an invocation of **mount** is determined by first extracting the mount options for the filesystem from the <u>fstab</u> table, then applying any options specified by the **-o** argument, and finally applying a **-r** or **-w** option, when present.

<br>

- The **mount** command does not pass all command-line options to the **/sbin/mount**.<u>suffix</u> mount helpers.

- The interface between **mount** and the mount helpers is described below in the **EXTERNAL HELPERS** section.

<br>

- Command-line options available for the **mount** are:

    - **-o**, **--options** <u>opts</u>

        - Use the specified mount options.

        - The <u>opts</u> argument is a comma-separated list.

        - For example:

            <pre><b>mount LABEL=mydisk -o noatime,nodev,nosuid</u></pre>

        - Note that the order of the options matters, as the last option wins if there are conflicting ones.

        - The options from the command line also overwrite options from fstab by default.

        <br>

        - For more details, see the **FILESYSTEM-INDEPENDENT MOUNT OPTIONS** and **FILESYSTEM-SPECIFIC MOUNT OPTIONS** sections.

## LOOP-DEVICE SUPPORT

- One further possible type is a mount via the loop device.

- For example, the command

    <pre><b>mount /tmp/disk.img /mnt -t vfat -o loop=/dev/loop3</b></pre>

    - will set up the loop device <u>/dev/loop3</u> to correspond to the file <u>/tmp/disk.img</u>, and then mount this device on <u>/mnt</u>.

<br>

- If no explicit loop device is mentioned (but just an option '**-o loop**' is given), then **mount** will try to find some unused loop device and use that, for example

    <pre><b>mount /tmp/disk.img /mnt -o loop</b></pre>

- The **mount** command **automatically** creates a loop device from a regular file if a filesystem type is not specified or the filesystem is known for libblkid, for example:

    <pre><b>mount /tmp/disk.img /mnt</></pre>

    <pre><b>mount -t ext4 /tmp/disk.img /mnt</u><pre>

- This type of mount knows about three options, namely **loop**, **offset** and **sizelimit**, that are really options to **losetup**(8).

    - These options can be used in addition to those specific to the filesystem type.

<br>

- Since Linux 2.6.25 auto-destruction of loop devices is supported, meaning that any loop device allocated by **mount** will be freed by **umount** independently of <u>/etc/mtab</u>.

<br>

- You can also free a loop device by hand, using **losetup -d** or **umount -d**.

<br>

- Since util-linux v2.29, **mount** re-uses the loop device rather than initializing a new device if the same backing file is already used for some loop device with the same offset and sizelimit.

- This is necessary to avoid a filesystem corruption.
